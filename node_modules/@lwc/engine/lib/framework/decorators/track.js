"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../../shared/assert"));
const language_1 = require("../../shared/language");
const invoker_1 = require("../invoker");
const watcher_1 = require("../watcher");
const vm_1 = require("../vm");
const membrane_1 = require("../membrane");
function track(target, prop, descriptor) {
    if (arguments.length === 1) {
        return membrane_1.reactiveMembrane.getProxy(target);
    }
    if (process.env.NODE_ENV !== 'production') {
        if (arguments.length !== 3) {
            assert_1.default.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);
        }
        if (!language_1.isUndefined(descriptor)) {
            const { get, set, configurable, writable } = descriptor;
            assert_1.default.isTrue(!get && !set, `Compiler Error: A @track decorator can only be applied to a public field.`);
            assert_1.default.isTrue(configurable !== false, `Compiler Error: A @track decorator can only be applied to a configurable property.`);
            assert_1.default.isTrue(writable !== false, `Compiler Error: A @track decorator can only be applied to a writable property.`);
        }
    }
    return createTrackedPropertyDescriptor(target, prop, language_1.isUndefined(descriptor) ? true : descriptor.enumerable === true);
}
exports.default = track;
function createTrackedPropertyDescriptor(Ctor, key, enumerable) {
    return {
        get() {
            const vm = vm_1.getComponentVM(this);
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.isTrue(vm && "cmpRoot" in vm, `${vm} is not a vm.`);
            }
            watcher_1.observeMutation(this, key);
            return vm.cmpTrack[key];
        },
        set(newValue) {
            const vm = vm_1.getComponentVM(this);
            if (process.env.NODE_ENV !== 'production') {
                assert_1.default.isTrue(vm && "cmpRoot" in vm, `${vm} is not a vm.`);
                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm}.${String(key)}`);
            }
            const reactiveOrAnyValue = membrane_1.reactiveMembrane.getProxy(newValue);
            if (reactiveOrAnyValue !== vm.cmpTrack[key]) {
                if (process.env.NODE_ENV !== 'production') {
                    // reactiveMembrane.getProxy(newValue) will return a different value (proxy)
                    // Then newValue if newValue is observable (plain object or array)
                    const isObservable = reactiveOrAnyValue !== newValue;
                    if (!isObservable && newValue !== null && (language_1.isObject(newValue) || language_1.isArray(newValue))) {
                        assert_1.default.logWarning(`Property "${language_1.toString(key)}" of ${vm} is set to a non-trackable object, which means changes into that object cannot be observed.`, vm.elm);
                    }
                }
                vm.cmpTrack[key] = reactiveOrAnyValue;
                if (vm.idx > 0) {
                    // perf optimization to skip this step if not in the DOM
                    watcher_1.notifyMutation(this, key);
                }
            }
        },
        enumerable,
        configurable: true,
    };
}
exports.createTrackedPropertyDescriptor = createTrackedPropertyDescriptor;
//# sourceMappingURL=track.js.map