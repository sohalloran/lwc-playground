"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../../shared/assert"));
const language_1 = require("../../shared/language");
const fields_1 = require("../../shared/fields");
const utils_1 = require("../utils");
const api_1 = require("../decorators/api");
const attributes_1 = require("../attributes");
const EspecialTagAndPropMap = language_1.create(null, {
    input: { value: language_1.create(null, { value: { value: 1 }, checked: { value: 1 } }) },
    select: { value: language_1.create(null, { value: { value: 1 } }) },
    textarea: { value: language_1.create(null, { value: { value: 1 } }) },
});
function isLiveBindingProp(sel, key) {
    // For special whitelisted properties (e.g., `checked` and `value`), we
    // check against the actual property value on the DOM element instead of
    // relying on tracked property values.
    return (language_1.hasOwnProperty.call(EspecialTagAndPropMap, sel) &&
        language_1.hasOwnProperty.call(EspecialTagAndPropMap[sel], key));
}
function update(oldVnode, vnode) {
    const props = vnode.data.props;
    if (language_1.isUndefined(props)) {
        return;
    }
    const oldProps = oldVnode.data.props;
    if (oldProps === props) {
        return;
    }
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(language_1.isUndefined(oldProps) || language_1.keys(oldProps).join(',') === language_1.keys(props).join(','), 'vnode.data.props cannot change shape.');
    }
    const elm = vnode.elm;
    const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);
    const isFirstPatch = language_1.isUndefined(oldProps);
    const isCustomElement = !language_1.isUndefined(vm);
    const { sel } = vnode;
    for (const key in props) {
        const cur = props[key];
        if (process.env.NODE_ENV !== 'production') {
            if (!(key in elm)) {
                // TODO: this should never really happen because the compiler should always validate
                assert_1.default.fail(`Unknown public property "${key}" of element <${sel}>. This is likely a typo on the corresponding attribute "${attributes_1.getAttrNameFromPropName(key)}".`);
            }
        }
        // if it is the first time this element is patched, or the current value is different to the previous value...
        if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {
            if (isCustomElement) {
                api_1.prepareForPropUpdate(vm); // this is just in case the vnode is actually a custom element
            }
            elm[key] = cur;
        }
    }
}
const emptyVNode = { data: {} };
exports.default = {
    create: (vnode) => update(emptyVNode, vnode),
    update,
};
//# sourceMappingURL=props.js.map