"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const utils_1 = require("./utils");
const vm_1 = require("./vm");
const node_1 = require("../env/node");
const events_1 = __importDefault(require("./modules/events"));
const attrs_1 = __importDefault(require("./modules/attrs"));
const props_1 = __importDefault(require("./modules/props"));
const computed_class_attr_1 = __importDefault(require("./modules/computed-class-attr"));
const computed_style_attr_1 = __importDefault(require("./modules/computed-style-attr"));
const static_class_attr_1 = __importDefault(require("./modules/static-class-attr"));
const static_style_attr_1 = __importDefault(require("./modules/static-style-attr"));
const context_1 = __importDefault(require("./modules/context"));
const patch_1 = require("./patch");
const snabbdom_1 = require("../3rdparty/snabbdom/snabbdom");
const restrictions_1 = require("./restrictions");
const patch_2 = require("./patch");
const def_1 = require("./def");
function updateNodeHook(oldVnode, vnode) {
    if (oldVnode.text !== vnode.text) {
        node_1.nodeValueSetter.call(vnode.elm, vnode.text);
    }
}
exports.updateNodeHook = updateNodeHook;
function insertNodeHook(vnode, parentNode, referenceNode) {
    node_1.insertBefore.call(parentNode, vnode.elm, referenceNode);
}
exports.insertNodeHook = insertNodeHook;
function removeNodeHook(vnode, parentNode) {
    node_1.removeChild.call(parentNode, vnode.elm);
}
exports.removeNodeHook = removeNodeHook;
function createTextHook(vnode) {
    const text = vnode.elm;
    vm_1.setNodeOwnerKey(text, vnode.uid);
    if (language_1.isTrue(vnode.fallback)) {
        patch_2.patchTextNodeProto(text);
    }
}
exports.createTextHook = createTextHook;
function createCommentHook(vnode) {
    const comment = vnode.elm;
    vm_1.setNodeOwnerKey(comment, vnode.uid);
    if (language_1.isTrue(vnode.fallback)) {
        patch_2.patchCommentNodeProto(comment);
    }
}
exports.createCommentHook = createCommentHook;
function createElmDefaultHook(vnode) {
    events_1.default.create(vnode);
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.create(vnode);
    props_1.default.create(vnode);
    static_class_attr_1.default.create(vnode);
    static_style_attr_1.default.create(vnode);
    computed_class_attr_1.default.create(vnode);
    computed_style_attr_1.default.create(vnode);
    context_1.default.create(vnode);
}
exports.createElmDefaultHook = createElmDefaultHook;
var LWCDOMMode;
(function (LWCDOMMode) {
    LWCDOMMode["manual"] = "manual";
})(LWCDOMMode || (LWCDOMMode = {}));
function createElmHook(vnode) {
    const { uid, sel, fallback } = vnode;
    const elm = vnode.elm;
    vm_1.setNodeOwnerKey(elm, uid);
    if (language_1.isTrue(fallback)) {
        const { shadowAttribute, data: { context } } = vnode;
        const isPortal = !language_1.isUndefined(context) && !language_1.isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual;
        patch_2.patchElementProto(elm, {
            sel,
            isPortal,
            shadowAttribute,
        });
    }
    if (process.env.NODE_ENV !== 'production') {
        const { data: { context } } = vnode;
        const isPortal = !language_1.isUndefined(context) && !language_1.isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual;
        restrictions_1.patchElementWithRestrictions(elm, { isPortal });
    }
}
exports.createElmHook = createElmHook;
function updateElmDefaultHook(oldVnode, vnode) {
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.update(oldVnode, vnode);
    props_1.default.update(oldVnode, vnode);
    computed_class_attr_1.default.update(oldVnode, vnode);
    computed_style_attr_1.default.update(oldVnode, vnode);
}
exports.updateElmDefaultHook = updateElmDefaultHook;
function insertCustomElmHook(vnode) {
    const vm = vm_1.getCustomElementVM(vnode.elm);
    vm_1.appendVM(vm);
    vm_1.renderVM(vm);
}
exports.insertCustomElmHook = insertCustomElmHook;
function updateChildrenHook(oldVnode, vnode) {
    const { children } = vnode;
    const fn = patch_1.hasDynamicChildren(children) ? snabbdom_1.updateDynamicChildren : snabbdom_1.updateStaticChildren;
    fn(vnode.elm, oldVnode.children, children);
}
exports.updateChildrenHook = updateChildrenHook;
function allocateChildrenHook(vnode) {
    if (language_1.isTrue(vnode.fallback)) {
        // slow path
        const elm = vnode.elm;
        const vm = vm_1.getCustomElementVM(elm);
        const children = vnode.children;
        vm_1.allocateInSlot(vm, children);
        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
        vnode.children = utils_1.EmptyArray;
    }
}
exports.allocateChildrenHook = allocateChildrenHook;
function createCustomElmHook(vnode) {
    const elm = vnode.elm;
    if (language_1.hasOwnProperty.call(elm, utils_1.ViewModelReflection)) {
        // There is a possibility that a custom element is registered under tagName,
        // in which case, the initialization is already carry on, and there is nothing else
        // to do here since this hook is called right after invoking `document.createElement`.
        return;
    }
    const { mode, ctor, uid, fallback } = vnode;
    vm_1.setNodeOwnerKey(elm, uid);
    const def = def_1.getComponentDef(ctor);
    def_1.setElementProto(elm, def);
    if (language_1.isTrue(fallback)) {
        const { shadowAttribute } = vnode;
        patch_2.patchCustomElementProto(elm, {
            def,
            shadowAttribute,
        });
    }
    vm_1.createVM(vnode.sel, elm, ctor, {
        mode,
        fallback,
    });
    const vm = vm_1.getCustomElementVM(elm);
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && "cmpRoot" in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(language_1.isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);
    }
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.patchCustomElementWithRestrictions(elm, utils_1.EmptyObject);
    }
}
exports.createCustomElmHook = createCustomElmHook;
function createCustomElmDefaultHook(vnode) {
    events_1.default.create(vnode);
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.create(vnode);
    props_1.default.create(vnode);
    static_class_attr_1.default.create(vnode);
    static_style_attr_1.default.create(vnode);
    computed_class_attr_1.default.create(vnode);
    computed_style_attr_1.default.create(vnode);
    context_1.default.create(vnode);
}
exports.createCustomElmDefaultHook = createCustomElmDefaultHook;
function createChildrenHook(vnode) {
    const { elm, children } = vnode;
    for (let j = 0; j < children.length; ++j) {
        const ch = children[j];
        if (ch != null) {
            ch.hook.create(ch);
            ch.hook.insert(ch, elm, null);
        }
    }
}
exports.createChildrenHook = createChildrenHook;
function renderCustomElmHook(vnode) {
    const vm = vm_1.getCustomElementVM(vnode.elm);
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && "cmpRoot" in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(language_1.isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);
    }
    vm_1.renderVM(vm);
}
exports.renderCustomElmHook = renderCustomElmHook;
function updateCustomElmDefaultHook(oldVnode, vnode) {
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.update(oldVnode, vnode);
    props_1.default.update(oldVnode, vnode);
    computed_class_attr_1.default.update(oldVnode, vnode);
    computed_style_attr_1.default.update(oldVnode, vnode);
}
exports.updateCustomElmDefaultHook = updateCustomElmDefaultHook;
function removeElmHook(vnode) {
    vnode.hook.destroy(vnode);
}
exports.removeElmHook = removeElmHook;
function destroyCustomElmHook(vnode) {
    vm_1.removeVM(vm_1.getCustomElementVM(vnode.elm));
}
exports.destroyCustomElmHook = destroyCustomElmHook;
function destroyElmHook(vnode) {
    const { children } = vnode;
    for (let j = 0, len = children.length; j < len; ++j) {
        const ch = children[j];
        if (ch != null) {
            ch.hook.destroy(ch);
        }
    }
}
exports.destroyElmHook = destroyElmHook;
//# sourceMappingURL=hooks.js.map