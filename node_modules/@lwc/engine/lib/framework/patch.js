"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const faux_1 = require("../faux-shadow/faux");
exports.patchEvent = faux_1.patchEvent;
const element_1 = require("../env/element");
const snabbdom_1 = require("../3rdparty/snabbdom/snabbdom");
const language_1 = require("../shared/language");
const faux_2 = require("../faux-shadow/faux");
// Using a WeakMap instead of a WeakSet because this one works in IE11 :(
const FromIteration = new WeakMap();
// dynamic children means it was generated by an iteration
// in a template, and will require a more complex diffing algo.
function markAsDynamicChildren(children) {
    FromIteration.set(children, 1);
}
exports.markAsDynamicChildren = markAsDynamicChildren;
function hasDynamicChildren(children) {
    return FromIteration.has(children);
}
exports.hasDynamicChildren = hasDynamicChildren;
function patchChildren(host, shadowRoot, oldCh, newCh, isFallback) {
    if (oldCh !== newCh) {
        const parentNode = isFallback ? host : shadowRoot;
        const fn = hasDynamicChildren(newCh) ? snabbdom_1.updateDynamicChildren : snabbdom_1.updateStaticChildren;
        fn(parentNode, oldCh, newCh);
    }
}
exports.patchChildren = patchChildren;
let TextNodeProto;
// this method is supposed to be invoked when in fallback mode only
// to patch text nodes generated by a template.
function patchTextNodeProto(text) {
    if (language_1.isUndefined(TextNodeProto)) {
        TextNodeProto = faux_2.PatchedNode(text).prototype;
    }
    language_1.setPrototypeOf(text, TextNodeProto);
}
exports.patchTextNodeProto = patchTextNodeProto;
let CommentNodeProto;
// this method is supposed to be invoked when in fallback mode only
// to patch comment nodes generated by a template.
function patchCommentNodeProto(comment) {
    if (language_1.isUndefined(CommentNodeProto)) {
        CommentNodeProto = faux_2.PatchedNode(comment).prototype;
    }
    language_1.setPrototypeOf(comment, CommentNodeProto);
}
exports.patchCommentNodeProto = patchCommentNodeProto;
const TagToProtoCache = language_1.create(null);
function getPatchedElementClass(elm) {
    switch (element_1.tagNameGetter.call(elm)) {
        case 'SLOT':
            return faux_2.PatchedSlotElement(elm);
        case 'IFRAME':
            return faux_2.PatchedIframeElement(elm);
    }
    return faux_2.PatchedElement(elm);
}
// this method is supposed to be invoked when in fallback mode only
// to patch elements generated by a template.
function patchElementProto(elm, options) {
    const { sel, isPortal, shadowAttribute } = options;
    let proto = TagToProtoCache[sel];
    if (language_1.isUndefined(proto)) {
        proto = TagToProtoCache[sel] = getPatchedElementClass(elm).prototype;
    }
    language_1.setPrototypeOf(elm, proto);
    if (language_1.isTrue(isPortal)) {
        faux_2.markElementAsPortal(elm);
    }
    faux_2.setCSSToken(elm, shadowAttribute);
}
exports.patchElementProto = patchElementProto;
function patchCustomElementProto(elm, options) {
    const { def, shadowAttribute } = options;
    let patchedBridge = def.patchedBridge;
    if (language_1.isUndefined(patchedBridge)) {
        patchedBridge = def.patchedBridge = faux_2.PatchedCustomElement(elm);
    }
    // temporary patching the proto, eventually this should be just more nodes in the proto chain
    language_1.setPrototypeOf(elm, patchedBridge.prototype);
    faux_2.setCSSToken(elm, shadowAttribute);
}
exports.patchCustomElementProto = patchCustomElementProto;
//# sourceMappingURL=patch.js.map