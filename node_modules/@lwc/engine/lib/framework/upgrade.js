"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const vm_1 = require("./vm");
const utils_1 = require("./utils");
const fields_1 = require("../shared/fields");
const dom_1 = require("../env/dom");
const patch_1 = require("./patch");
const def_1 = require("./def");
const restrictions_1 = require("./restrictions");
const performance_timing_1 = require("./performance-timing");
const node_1 = require("../env/node");
const ConnectingSlot = fields_1.createFieldName('connecting');
const DisconnectingSlot = fields_1.createFieldName('disconnecting');
function callNodeSlot(node, slot) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(node, `callNodeSlot() should not be called for a non-object`);
    }
    const fn = fields_1.getInternalField(node, slot);
    if (!language_1.isUndefined(fn)) {
        fn();
    }
    return node; // for convenience
}
// monkey patching Node methods to be able to detect the insertions and removal of
// root elements created via createElement.
language_1.assign(Node.prototype, {
    appendChild(newChild) {
        const appendedNode = node_1.appendChild.call(this, newChild);
        return callNodeSlot(appendedNode, ConnectingSlot);
    },
    insertBefore(newChild, referenceNode) {
        const insertedNode = node_1.insertBefore.call(this, newChild, referenceNode);
        return callNodeSlot(insertedNode, ConnectingSlot);
    },
    removeChild(oldChild) {
        const removedNode = node_1.removeChild.call(this, oldChild);
        return callNodeSlot(removedNode, DisconnectingSlot);
    },
    replaceChild(newChild, oldChild) {
        const replacedNode = node_1.replaceChild.call(this, newChild, oldChild);
        callNodeSlot(replacedNode, DisconnectingSlot);
        callNodeSlot(newChild, ConnectingSlot);
        return replacedNode;
    },
});
/**
 * This method is almost identical to document.createElement
 * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)
 * with the slightly difference that in the options, you can pass the `is`
 * property set to a Constructor instead of just a string value. E.g.:
 *
 * const el = createElement('x-foo', { is: FooCtor });
 *
 * If the value of `is` attribute is not a constructor,
 * then it throws a TypeError.
 */
function createElement(sel, options = {}) {
    performance_timing_1.startGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.INIT);
    if (!language_1.isObject(options) || language_1.isNull(options)) {
        throw new TypeError();
    }
    let Ctor = options.is;
    if (utils_1.isCircularModuleDependency(Ctor)) {
        Ctor = utils_1.resolveCircularModuleDependency(Ctor);
    }
    let { mode, fallback } = options;
    // TODO: for now, we default to open, but eventually it should default to 'closed'
    if (mode !== 'closed') {
        mode = 'open';
    }
    // TODO: for now, we default to true, but eventually it should default to false
    fallback = language_1.isUndefined(fallback) || language_1.isTrue(fallback) || language_1.isFalse(dom_1.isNativeShadowRootAvailable);
    // Create element with correct tagName
    const element = document.createElement(sel);
    if (!language_1.isUndefined(vm_1.getNodeKey(element))) {
        // There is a possibility that a custom element is registered under tagName,
        // in which case, the initialization is already carry on, and there is nothing else
        // to do here.
        return element;
    }
    const def = def_1.getComponentDef(Ctor);
    def_1.setElementProto(element, def);
    if (language_1.isTrue(fallback)) {
        patch_1.patchCustomElementProto(element, {
            def
        });
    }
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.patchCustomElementWithRestrictions(element, utils_1.EmptyObject);
    }
    // In case the element is not initialized already, we need to carry on the manual creation
    vm_1.createVM(sel, element, Ctor, { mode, fallback, isRoot: true });
    // Handle insertion and removal from the DOM manually
    fields_1.setInternalField(element, ConnectingSlot, () => {
        performance_timing_1.startGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.HYDRATE);
        const vm = vm_1.getCustomElementVM(element);
        vm_1.removeVM(vm); // moving the element from one place to another is observable via life-cycle hooks
        vm_1.appendVM(vm);
        vm_1.renderVM(vm);
        performance_timing_1.endGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.HYDRATE);
    });
    fields_1.setInternalField(element, DisconnectingSlot, () => {
        const vm = vm_1.getCustomElementVM(element);
        vm_1.removeVM(vm);
    });
    performance_timing_1.endGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.INIT);
    return element;
}
exports.createElement = createElement;
//# sourceMappingURL=upgrade.js.map