"use strict";
/**
 * This module is responsible for producing the ComponentDef object that is always
 * accessible via `vm.def`. This is lazily created during the creation of the first
 * instance of a component class, and shared across all instances.
 *
 * This structure can be used to synthetically create proxies, and understand the
 * shape of a component. It is also used internally to apply extra optimizations.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const fields_1 = require("../shared/fields");
const attributes_1 = require("./attributes");
const utils_1 = require("./utils");
const component_1 = require("./component");
const CtorToDefMap = new WeakMap();
function getCtorProto(Ctor, subclassComponentName) {
    let proto = language_1.getPrototypeOf(Ctor);
    if (language_1.isNull(proto)) {
        throw new ReferenceError(`Invalid prototype chain for ${subclassComponentName}, you must extend LightningElement.`);
    }
    // covering the cases where the ref is circular in AMD
    if (utils_1.isCircularModuleDependency(proto)) {
        const p = utils_1.resolveCircularModuleDependency(proto);
        if (process.env.NODE_ENV !== 'production') {
            if (language_1.isNull(p)) {
                throw new ReferenceError(`Circular module dependency for ${subclassComponentName}, must resolve to a constructor that extends LightningElement.`);
            }
        }
        // escape hatch for Locker and other abstractions to provide their own base class instead
        // of our Base class without having to leak it to user-land. If the circular function returns
        // itself, that's the signal that we have hit the end of the proto chain, which must always
        // be base.
        proto = p === proto ? base_lightning_element_1.BaseLightningElement : p;
    }
    return proto;
}
function isElementComponent(Ctor, subclassComponentName, protoSet) {
    protoSet = protoSet || [];
    if (!Ctor || language_1.ArrayIndexOf.call(protoSet, Ctor) >= 0) {
        return false; // null, undefined, or circular prototype definition
    }
    const proto = getCtorProto(Ctor, subclassComponentName);
    if (proto === base_lightning_element_1.BaseLightningElement) {
        return true;
    }
    getComponentDef(proto, subclassComponentName); // ensuring that the prototype chain is already expanded
    language_1.ArrayPush.call(protoSet, Ctor);
    return isElementComponent(proto, subclassComponentName, protoSet);
}
function createComponentDef(Ctor, meta, subclassComponentName) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(isElementComponent(Ctor, subclassComponentName), `${Ctor} is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.`);
        // local to dev block
        const ctorName = Ctor.name;
        // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.
        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a "name" property with string value, but found ${ctorName}.`);
        assert_1.default.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a "constructor" property.`);
    }
    const { name, template } = meta;
    let decoratorsMeta = register_1.getDecoratorsRegisteredMeta(Ctor);
    // TODO: eventually, the compiler should do this call directly, but we will also
    // have to fix all our tests, which are using this declaration manually.
    if (language_1.isUndefined(decoratorsMeta)) {
        register_1.registerDecorators(Ctor, {
            publicMethods: getOwnValue(Ctor, 'publicMethods'),
            publicProps: getOwnValue(Ctor, 'publicProps'),
            track: getOwnValue(Ctor, 'track'),
            wire: getOwnValue(Ctor, 'wire'),
        });
        decoratorsMeta = register_1.getDecoratorsRegisteredMeta(Ctor);
    }
    let { props, methods, wire, track } = decoratorsMeta || utils_1.EmptyObject;
    const proto = Ctor.prototype;
    let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, render, } = proto;
    const superProto = getCtorProto(Ctor, subclassComponentName);
    const superDef = superProto !== base_lightning_element_1.BaseLightningElement ? getComponentDef(superProto, subclassComponentName) : null;
    const SuperBridge = language_1.isNull(superDef) ? base_bridge_element_1.BaseBridgeElement : superDef.bridge;
    const bridge = base_bridge_element_1.HTMLBridgeElementFactory(SuperBridge, language_1.getOwnPropertyNames(props), language_1.getOwnPropertyNames(methods));
    if (!language_1.isNull(superDef)) {
        props = language_1.assign(language_1.create(null), superDef.props, props);
        methods = language_1.assign(language_1.create(null), superDef.methods, methods);
        wire = (superDef.wire || wire) ? language_1.assign(language_1.create(null), superDef.wire, wire) : undefined;
        track = language_1.assign(language_1.create(null), superDef.track, track);
        connectedCallback = connectedCallback || superDef.connectedCallback;
        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
        renderedCallback = renderedCallback || superDef.renderedCallback;
        errorCallback = errorCallback || superDef.errorCallback;
        render = render || superDef.render;
    }
    props = language_1.assign(language_1.create(null), HTML_PROPS, props);
    const def = {
        ctor: Ctor,
        name,
        wire,
        track,
        props,
        methods,
        bridge,
        template,
        connectedCallback,
        disconnectedCallback,
        renderedCallback,
        errorCallback,
        render,
    };
    if (process.env.NODE_ENV !== 'production') {
        language_1.freeze(Ctor.prototype);
    }
    return def;
}
function isComponentConstructor(Ctor) {
    return isElementComponent(Ctor, Ctor.name);
}
exports.isComponentConstructor = isComponentConstructor;
function getOwnValue(o, key) {
    const d = language_1.getOwnPropertyDescriptor(o, key);
    return d && d.value;
}
function getComponentDef(Ctor, subclassComponentName) {
    let def = CtorToDefMap.get(Ctor);
    if (def) {
        return def;
    }
    let meta = component_1.getComponentRegisteredMeta(Ctor);
    if (language_1.isUndefined(meta)) {
        // TODO: remove this workaround:
        // this is temporary until
        // all tests are updated to call registerComponent:
        meta = {
            template: undefined,
            name: Ctor.name,
        };
    }
    def = createComponentDef(Ctor, meta, subclassComponentName || Ctor.name);
    CtorToDefMap.set(Ctor, def);
    return def;
}
exports.getComponentDef = getComponentDef;
/**
 * Returns the component constructor for a given HTMLElement if it can be found
 * @param {HTMLElement} element
 * @return {ComponentConstructor | null}
 */
function getComponentConstructor(elm) {
    let ctor = null;
    if (elm instanceof HTMLElement) {
        const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);
        if (!language_1.isUndefined(vm)) {
            ctor = vm.def.ctor;
        }
    }
    return ctor;
}
exports.getComponentConstructor = getComponentConstructor;
// Only set prototype for public methods and properties
// No DOM Patching occurs here
function setElementProto(elm, def) {
    language_1.setPrototypeOf(elm, def.bridge.prototype);
}
exports.setElementProto = setElementProto;
const html_properties_1 = require("./html-properties");
const base_lightning_element_1 = require("./base-lightning-element");
const base_bridge_element_1 = require("./base-bridge-element");
const register_1 = require("./decorators/register");
const HTML_PROPS = language_1.ArrayReduce.call(language_1.getOwnPropertyNames(html_properties_1.HTMLElementOriginalDescriptors), (props, propName) => {
    const attrName = attributes_1.getAttrNameFromPropName(propName);
    props[propName] = {
        config: 3,
        type: 'any',
        attr: attrName,
    };
    return props;
}, language_1.create(null));
//# sourceMappingURL=def.js.map