"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../shared/assert"));
const context_1 = require("./context");
const template_1 = require("./template");
const language_1 = require("../shared/language");
const vm_1 = require("./vm");
const performance_timing_1 = require("./performance-timing");
exports.isRendering = false;
exports.vmBeingRendered = null;
exports.vmBeingConstructed = null;
function isBeingConstructed(vm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && "cmpRoot" in vm, `${vm} is not a vm.`);
    }
    return exports.vmBeingConstructed === vm;
}
exports.isBeingConstructed = isBeingConstructed;
function invokeComponentCallback(vm, fn, args) {
    const { context, component, callHook } = vm;
    const ctx = context_1.currentContext;
    context_1.establishContext(context);
    let result;
    let error;
    try {
        result = callHook(component, fn, args);
    }
    catch (e) {
        error = Object(e);
    }
    finally {
        context_1.establishContext(ctx);
        if (error) {
            error.wcStack = vm_1.getErrorComponentStack(vm.elm);
            // rethrowing the original error annotated after restoring the context
            throw error; // tslint:disable-line
        }
    }
    return result;
}
exports.invokeComponentCallback = invokeComponentCallback;
function invokeComponentConstructor(vm, Ctor) {
    const { context } = vm;
    const ctx = context_1.currentContext;
    context_1.establishContext(context);
    const vmBeingConstructedInception = exports.vmBeingConstructed;
    exports.vmBeingConstructed = vm;
    if (process.env.NODE_ENV !== 'production') {
        performance_timing_1.startMeasure(vm, 'constructor');
    }
    let error;
    try {
        new Ctor(); // tslint:disable-line
    }
    catch (e) {
        error = Object(e);
    }
    finally {
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.endMeasure(vm, 'constructor');
        }
        context_1.establishContext(ctx);
        exports.vmBeingConstructed = vmBeingConstructedInception;
        if (error) {
            error.wcStack = vm_1.getErrorComponentStack(vm.elm);
            // rethrowing the original error annotated after restoring the context
            throw error; // tslint:disable-line
        }
    }
}
exports.invokeComponentConstructor = invokeComponentConstructor;
function invokeComponentRenderMethod(vm) {
    const { def: { render }, callHook } = vm;
    const { component, context } = vm;
    const ctx = context_1.currentContext;
    context_1.establishContext(context);
    const isRenderingInception = exports.isRendering;
    const vmBeingRenderedInception = exports.vmBeingRendered;
    exports.isRendering = true;
    exports.vmBeingRendered = vm;
    let result;
    let error;
    if (process.env.NODE_ENV !== 'production') {
        performance_timing_1.startMeasure(vm, 'render');
    }
    try {
        const html = callHook(component, render);
        result = template_1.evaluateTemplate(vm, html);
    }
    catch (e) {
        error = Object(e);
    }
    finally {
        if (process.env.NODE_ENV !== 'production') {
            performance_timing_1.endMeasure(vm, 'render');
        }
        context_1.establishContext(ctx);
        exports.isRendering = isRenderingInception;
        exports.vmBeingRendered = vmBeingRenderedInception;
        if (error) {
            error.wcStack = vm_1.getErrorComponentStack(vm.elm);
            // rethrowing the original error annotated after restoring the context
            throw error; // tslint:disable-line
        }
    }
    return result || [];
}
exports.invokeComponentRenderMethod = invokeComponentRenderMethod;
function invokeEventListener(vm, fn, thisValue, event) {
    const { context, callHook } = vm;
    const ctx = context_1.currentContext;
    context_1.establishContext(context);
    let error;
    try {
        if (process.env.NODE_ENV !== 'production') {
            assert_1.default.isTrue(language_1.isFunction(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);
        }
        callHook(thisValue, fn, [event]);
    }
    catch (e) {
        error = Object(e);
    }
    finally {
        context_1.establishContext(ctx);
        if (error) {
            error.wcStack = vm_1.getErrorComponentStack(vm.elm);
            // rethrowing the original error annotated after restoring the context
            throw error; // tslint:disable-line
        }
    }
}
exports.invokeEventListener = invokeEventListener;
//# sourceMappingURL=invoker.js.map