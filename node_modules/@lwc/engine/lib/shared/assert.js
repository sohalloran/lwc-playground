"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const language_1 = require("./language");
const element_1 = require("../env/element");
const node_1 = require("../env/node");
const dom_1 = require("../env/dom");
const StringSplit = String.prototype.split;
function isLWC(element) {
    return (element instanceof Element) && (element_1.tagNameGetter.call(element).indexOf('-') !== -1);
}
function isShadowRoot(elmOrShadow) {
    return !(elmOrShadow instanceof Element) && ('host' in elmOrShadow);
}
function getFormattedComponentStack(elm) {
    const componentStack = [];
    const indentationChar = '\t';
    let indentation = '';
    let currentElement = elm;
    do {
        if (isLWC(currentElement)) {
            language_1.ArrayPush.call(componentStack, `${indentation}<${language_1.StringToLowerCase.call(element_1.tagNameGetter.call(currentElement))}>`);
            indentation = indentation + indentationChar;
        }
        if (isShadowRoot(currentElement)) {
            // if at some point we find a ShadowRoot, it must be a native shadow root.
            currentElement = dom_1.ShadowRootHostGetter.call(currentElement);
        }
        else {
            currentElement = node_1.parentNodeGetter.call(currentElement);
        }
    } while (!language_1.isNull(currentElement));
    return language_1.ArrayJoin.call(componentStack, '\n');
}
const assert = {
    invariant(value, msg) {
        if (!value) {
            throw new Error(`Invariant Violation: ${msg}`);
        }
    },
    isTrue(value, msg) {
        if (!value) {
            throw new Error(`Assert Violation: ${msg}`);
        }
    },
    isFalse(value, msg) {
        if (value) {
            throw new Error(`Assert Violation: ${msg}`);
        }
    },
    fail(msg) {
        throw new Error(msg);
    },
    logError(message, elm) {
        let msg = `[LWC error]: ${message}`;
        if (elm) {
            msg = `${msg}\n${getFormattedComponentStack(elm)}`;
        }
        if (process.env.NODE_ENV === 'test') {
            console.error(msg); // tslint:disable-line
            return;
        }
        try {
            throw new Error(msg);
        }
        catch (e) {
            console.error(e); // tslint:disable-line
        }
    },
    logWarning(message, elm) {
        let msg = `[LWC warning]: ${message}`;
        if (elm) {
            msg = `${msg}\n${getFormattedComponentStack(elm)}`;
        }
        if (process.env.NODE_ENV === 'test') {
            console.warn(msg); // tslint:disable-line
            return;
        }
        try {
            throw new Error('error to get stacktrace');
        }
        catch (e) {
            // first line is the dummy message and second this function (which does not need to be there)
            const stackTraceLines = StringSplit.call(e.stack, '\n').splice(2);
            console.group(msg); // tslint:disable-line
            language_1.forEach.call(stackTraceLines, (trace) => {
                // We need to format this as a string,
                // because Safari will detect that the string
                // is a stack trace line item and will format it as so
                console.log('%s', trace.trim()); // tslint:disable-line
            });
            console.groupEnd(); // tslint:disable-line
        }
    },
};
exports.default = assert;
//# sourceMappingURL=assert.js.map