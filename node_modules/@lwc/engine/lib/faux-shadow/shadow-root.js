"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const events_1 = require("./events");
const traverse_1 = require("./traverse");
const fields_1 = require("../shared/fields");
const text_content_1 = require("../3rdparty/polymer/text-content");
const static_node_list_1 = require("../shared/static-node-list");
const document_1 = require("../env/document");
const node_1 = require("../env/node");
const dom_1 = require("../env/dom");
const static_html_collection_1 = require("../shared/static-html-collection");
const outer_html_1 = require("../3rdparty/polymer/outer-html");
const retarget_1 = require("../3rdparty/polymer/retarget");
const path_composer_1 = require("../3rdparty/polymer/path-composer");
const HostKey = fields_1.createFieldName('host');
const ShadowRootKey = fields_1.createFieldName('shadowRoot');
const { createDocumentFragment } = document;
function isDelegatingFocus(host) {
    const shadowRoot = getShadowRoot(host);
    return shadowRoot.delegatesFocus;
}
exports.isDelegatingFocus = isDelegatingFocus;
function getHost(root) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(root[HostKey], `A 'ShadowRoot' node must be attached to an 'HTMLElement' node.`);
    }
    return root[HostKey];
}
exports.getHost = getHost;
function getShadowRoot(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(fields_1.getInternalField(elm, ShadowRootKey), `A Custom Element with a shadow attached must be provided as the first argument.`);
    }
    return fields_1.getInternalField(elm, ShadowRootKey);
}
exports.getShadowRoot = getShadowRoot;
function attachShadow(elm, options) {
    if (fields_1.getInternalField(elm, ShadowRootKey)) {
        throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
    }
    const { mode, delegatesFocus } = options;
    // creating a real fragment for shadowRoot instance
    const sr = createDocumentFragment.call(document);
    language_1.defineProperty(sr, 'mode', {
        get() { return mode; },
        configurable: true,
        enumerable: true,
    });
    language_1.defineProperty(sr, 'delegatesFocus', {
        get() { return !!delegatesFocus; },
        configurable: true,
        enumerable: true,
    });
    // correcting the proto chain
    language_1.setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    fields_1.setInternalField(sr, HostKey, elm);
    fields_1.setInternalField(elm, ShadowRootKey, sr);
    // expose the shadow via a hidden symbol for testing purposes
    if (process.env.NODE_ENV === 'test') {
        elm['$$ShadowRoot$$'] = sr; // tslint:disable-line
    }
    return sr;
}
exports.attachShadow = attachShadow;
var ShadowRootMode;
(function (ShadowRootMode) {
    ShadowRootMode["CLOSED"] = "closed";
    ShadowRootMode["OPEN"] = "open";
})(ShadowRootMode = exports.ShadowRootMode || (exports.ShadowRootMode = {}));
class SyntheticShadowRoot extends DocumentFragment {
    constructor() {
        super();
        this.mode = ShadowRootMode.OPEN;
        this.delegatesFocus = false;
        throw new TypeError('Illegal constructor');
    }
    get nodeType() {
        return 11; // Node.DOCUMENT_FRAGMENT_NODE
    }
    get nodeName() {
        return '#document-fragment';
    }
    get nodeValue() {
        return null;
    }
    get namespaceURI() {
        return null;
    }
    get nextSibling() {
        return null;
    }
    get previousSibling() {
        return null;
    }
    get nextElementSibling() {
        return null;
    }
    get previousElementSibling() {
        return null;
    }
    get localName() {
        return null;
    }
    get prefix() {
        return;
    }
    get ownerDocument() {
        return getHost(this).ownerDocument;
    }
    get baseURI() {
        return getHost(this).baseURI;
    }
    get isConnected() {
        return (node_1.compareDocumentPosition.call(document, getHost(this)) & node_1.DOCUMENT_POSITION_CONTAINED_BY) !== 0;
    }
    get host() {
        return getHost(this);
    }
    get activeElement() {
        const activeElement = document_1.DocumentPrototypeActiveElement.call(document);
        if (language_1.isNull(activeElement)) {
            return activeElement;
        }
        const host = getHost(this);
        if ((node_1.compareDocumentPosition.call(host, activeElement) & node_1.DOCUMENT_POSITION_CONTAINED_BY) === 0) {
            return null;
        }
        // activeElement must be child of the host and owned by it
        let node = activeElement;
        while (!traverse_1.isNodeOwnedBy(host, node)) {
            node = node_1.parentElementGetter.call(node);
        }
        // If we have a slot element here
        // That means that we were dealing with an element that was passed to one of our slots
        // In this case, activeElement returns null
        if (traverse_1.isSlotElement(node)) {
            return null;
        }
        return node;
    }
    get firstChild() {
        const { childNodes } = this;
        return childNodes[0] || null;
    }
    get lastChild() {
        const { childNodes } = this;
        return childNodes[childNodes.length - 1] || null;
    }
    get innerHTML() {
        const { childNodes } = this;
        let innerHTML = '';
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
            innerHTML += outer_html_1.getOuterHTML(childNodes[i]);
        }
        return innerHTML;
    }
    get textContent() {
        const { childNodes } = this;
        let textContent = '';
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
            textContent += text_content_1.getTextContent(childNodes[i]);
        }
        return textContent;
    }
    get children() {
        return static_html_collection_1.createStaticHTMLCollection(language_1.ArrayFilter.call(traverse_1.shadowRootChildNodes(this), (elm) => elm instanceof Element));
    }
    // ParentNode.prototype
    get childElementCount() {
        return this.children.length;
    }
    get firstElementChild() {
        return this.children[0] || null;
    }
    get lastElementChild() {
        const { children } = this;
        return children.item(children.length - 1) || null;
    }
    get childNodes() {
        return static_node_list_1.createStaticNodeList(traverse_1.shadowRootChildNodes(this));
    }
    get parentNode() {
        return null;
    }
    get parentElement() {
        return null;
    }
    get styleSheets() {
        // TODO: implement
        throw new Error();
    }
    hasChildNodes() {
        return this.childNodes.length > 0;
    }
    /**
     * Returns the first element that is a descendant of node that
     * matches selectors.
     */
    querySelector(selectors) {
        return traverse_1.shadowRootQuerySelector(this, selectors);
    }
    /**
     * Returns all element descendants of node that
     * match selectors.
     */
    // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,
    // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,
    querySelectorAll(selectors) {
        return static_node_list_1.createStaticNodeList(traverse_1.shadowRootQuerySelectorAll(this, selectors));
    }
    addEventListener(type, listener, options) {
        events_1.addShadowRootEventListener(this, type, listener, options);
    }
    removeEventListener(type, listener, options) {
        events_1.removeShadowRootEventListener(this, type, listener, options);
    }
    compareDocumentPosition(otherNode) {
        const host = getHost(this);
        if (this === otherNode) {
            // it is the root itself
            return 0;
        }
        if (this.contains(otherNode)) {
            // it belongs to the shadow root instance
            return 20; // 10100 === DOCUMENT_POSITION_FOLLOWING & DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        }
        else if (node_1.compareDocumentPosition.call(host, otherNode) & node_1.DOCUMENT_POSITION_CONTAINED_BY) {
            // it is a child element but does not belong to the shadow root instance
            return 37; // 100101 === DOCUMENT_POSITION_DISCONNECTED & DOCUMENT_POSITION_FOLLOWING & DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        }
        else {
            // it is not a descendant
            return 35; // 100011 === DOCUMENT_POSITION_DISCONNECTED & DOCUMENT_POSITION_PRECEDING & DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        }
    }
    contains(otherNode) {
        const host = getHost(this);
        // must be child of the host and owned by it.
        return (node_1.compareDocumentPosition.call(host, otherNode) & node_1.DOCUMENT_POSITION_CONTAINED_BY) !== 0 &&
            traverse_1.isNodeOwnedBy(host, otherNode);
    }
    toString() {
        return `[object ShadowRoot]`;
    }
    // Same functionality as document.elementFromPoint
    // but we should only return elements that the shadow owns,
    // or are ancestors of the shadow
    elementFromPoint(left, top) {
        const element = document_1.elementFromPoint.call(document, left, top);
        if (language_1.isNull(element)) {
            return element;
        }
        return retarget_1.retarget(this, path_composer_1.pathComposer(element, true));
    }
    elementsFromPoint(left, top) {
        // TODO: implement
        throw new Error();
    }
    getSelection() {
        throw new Error();
    }
    getRootNode(options) {
        return traverse_1.getRootNodeGetter.call(this, options);
    }
}
exports.SyntheticShadowRoot = SyntheticShadowRoot;
// Is native ShadowDom is available on window,
// we need to make sure that our synthetic shadow dom
// passed instanceof checks against window.ShadowDom
if (dom_1.isNativeShadowRootAvailable) {
    language_1.setPrototypeOf(SyntheticShadowRoot.prototype, window.ShadowRoot.prototype);
}
//# sourceMappingURL=shadow-root.js.map