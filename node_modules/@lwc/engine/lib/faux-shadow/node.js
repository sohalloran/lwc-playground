"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const language_1 = require("../shared/language");
const node_1 = require("../env/node");
const window_1 = require("../env/window");
const element_1 = require("../env/element");
const traverse_1 = require("./traverse");
const text_content_1 = require("../3rdparty/polymer/text-content");
const shadow_root_1 = require("./shadow-root");
// DO NOT CHANGE this:
// these two values need to be in sync with framework/vm.ts
const OwnerKey = '$$OwnerKey$$';
const OwnKey = '$$OwnKey$$';
function getNodeOwnerKey(node) {
    return node[OwnerKey];
}
exports.getNodeOwnerKey = getNodeOwnerKey;
function setNodeOwnerKey(node, key) {
    node[OwnerKey] = key;
}
exports.setNodeOwnerKey = setNodeOwnerKey;
function getNodeNearestOwnerKey(node) {
    let ownerKey;
    // search for the first element with owner identity (just in case of manually inserted elements)
    while (!language_1.isNull(node) && language_1.isUndefined((ownerKey = node[OwnerKey]))) {
        node = node_1.parentNodeGetter.call(node);
    }
    return ownerKey;
}
exports.getNodeNearestOwnerKey = getNodeNearestOwnerKey;
function getNodeKey(node) {
    return node[OwnKey];
}
exports.getNodeKey = getNodeKey;
const portals = new WeakMap();
// We can use a single observer without having to worry about leaking because
// "Registered observers in a nodeâ€™s registered observer list have a weak
// reference to the node."
// https://dom.spec.whatwg.org/#garbage-collection
let portalObserver;
const portalObserverConfig = {
    childList: true,
    subtree: true,
};
function patchPortalElement(node, ownerKey, shadowToken) {
    // If node aleady has an ownerkey, we can skip
    // Note: checking if a node as any ownerKey is not enough
    // because this element could be moved from one
    // shadow to another
    if (getNodeOwnerKey(node) === ownerKey) {
        return;
    }
    setNodeOwnerKey(node, ownerKey);
    if (node instanceof Element) {
        setCSSToken(node, shadowToken);
        const { childNodes } = node;
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
            const child = childNodes[i];
            patchPortalElement(child, ownerKey, shadowToken);
        }
    }
}
function initPortalObserver() {
    return new window_1.MutationObserver(mutations => {
        language_1.forEach.call(mutations, mutation => {
            const { target: elm, addedNodes } = mutation;
            const ownerKey = getNodeOwnerKey(elm);
            const shadowToken = getCSSToken(elm);
            // OwnerKey might be undefined at this point.
            // We used to throw an error here, but we need to return early instead.
            //
            // This routine results in a mutation target that will have no key
            // because its been removed by the time the observer runs
            // const div = document.createElement('div');
            // div.innerHTML = '<span>span</span>';
            // const span = div.querySelector('span');
            // manualElement.appendChild(div);
            // span.textContent = '';
            // span.parentNode.removeChild(span);
            if (language_1.isUndefined(ownerKey)) {
                return;
            }
            for (let i = 0, len = addedNodes.length; i < len; i += 1) {
                const node = addedNodes[i];
                patchPortalElement(node, ownerKey, shadowToken);
            }
        });
    });
}
const ShadowTokenKey = '$$ShadowTokenKey$$';
function setCSSToken(elm, shadowToken) {
    if (!language_1.isUndefined(shadowToken)) {
        element_1.setAttribute.call(elm, shadowToken, '');
        elm[ShadowTokenKey] = shadowToken;
    }
}
exports.setCSSToken = setCSSToken;
function getCSSToken(elm) {
    return elm[ShadowTokenKey];
}
function markElementAsPortal(elm) {
    portals.set(elm, 1);
    if (!portalObserver) {
        portalObserver = initPortalObserver();
    }
    // install mutation observer for portals
    window_1.MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
}
exports.markElementAsPortal = markElementAsPortal;
function isPortalElement(elm) {
    return portals.has(elm);
}
exports.isPortalElement = isPortalElement;
function getShadowParent(node, value) {
    const owner = traverse_1.getNodeOwner(node);
    if (value === owner) {
        // walking up via parent chain might end up in the shadow root element
        return shadow_root_1.getShadowRoot(owner);
    }
    else if (value instanceof Element) {
        if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
            // the element and its parent node belong to the same shadow root
            return value;
        }
        else if (!language_1.isNull(owner) && traverse_1.isSlotElement(value)) {
            // slotted elements must be top level childNodes of the slot element
            // where they slotted into, but its shadowed parent is always the
            // owner of the slot.
            const slotOwner = traverse_1.getNodeOwner(value);
            if (!language_1.isNull(slotOwner) && traverse_1.isNodeOwnedBy(owner, slotOwner)) {
                // it is a slotted element, and therefore its parent is always going to be the host of the slot
                return slotOwner;
            }
        }
    }
    return null;
}
function PatchedNode(node) {
    const Ctor = language_1.getPrototypeOf(node).constructor;
    // @ts-ignore
    return class extends Ctor {
        hasChildNodes() {
            return this.childNodes.length > 0;
        }
        // @ts-ignore until ts@3.x
        get firstChild() {
            const { childNodes } = this;
            // @ts-ignore until ts@3.x
            return childNodes[0] || null;
        }
        // @ts-ignore until ts@3.x
        get lastChild() {
            const { childNodes } = this;
            // @ts-ignore until ts@3.x
            return childNodes[childNodes.length - 1] || null;
        }
        get textContent() {
            return text_content_1.getTextContent(this);
        }
        set textContent(value) {
            node_1.textContextSetter.call(this, value);
        }
        get childElementCount() {
            return this.children.length;
        }
        get firstElementChild() {
            return this.children[0] || null;
        }
        get lastElementChild() {
            const { children } = this;
            return children.item(children.length - 1) || null;
        }
        get assignedSlot() {
            const parentNode = node_1.parentNodeGetter.call(this);
            /**
             * if it doesn't have a parent node,
             * or the parent is not an slot element
             * or they both belong to the same template (default content)
             * we should assume that it is not slotted
             */
            if (language_1.isNull(parentNode) || !traverse_1.isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
                return null;
            }
            return parentNode;
        }
        get parentNode() {
            const value = node_1.parentNodeGetter.call(this);
            if (language_1.isNull(value)) {
                return value;
            }
            return getShadowParent(this, value);
        }
        get parentElement() {
            const parentNode = node_1.parentNodeGetter.call(this);
            if (language_1.isNull(parentNode)) {
                return null;
            }
            const nodeOwner = traverse_1.getNodeOwner(this);
            if (language_1.isNull(nodeOwner)) {
                return parentNode;
            }
            // If we have traversed to the host element,
            // we need to return null
            if (nodeOwner === parentNode) {
                return null;
            }
            return parentNode;
        }
        getRootNode(options) {
            return traverse_1.getRootNodeGetter.call(this, options);
        }
        compareDocumentPosition(otherNode) {
            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                // it is from another shadow
                return 0;
            }
            return node_1.compareDocumentPosition.call(this, otherNode);
        }
        contains(otherNode) {
            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                // it is from another shadow
                return false;
            }
            return (node_1.compareDocumentPosition.call(this, otherNode) & node_1.DOCUMENT_POSITION_CONTAINED_BY) !== 0;
        }
        cloneNode(deep) {
            const clone = node_1.cloneNode.call(this, false);
            // Per spec, browsers only care about truthy values
            // Not strict true or false
            if (!deep) {
                return clone;
            }
            const childNodes = this.childNodes;
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                clone.appendChild(childNodes[i].cloneNode(true));
            }
            return clone;
        }
    };
}
exports.PatchedNode = PatchedNode;
//# sourceMappingURL=node.js.map