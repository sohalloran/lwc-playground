"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shadow_root_1 = require("./shadow-root");
const events_1 = require("./events");
const traverse_1 = require("./traverse");
const element_1 = require("../env/element");
const language_1 = require("../shared/language");
const focus_1 = require("./focus");
const static_node_list_1 = require("../shared/static-node-list");
const static_html_collection_1 = require("../shared/static-html-collection");
function PatchedCustomElement(Base) {
    const Ctor = traverse_1.PatchedElement(Base);
    return class PatchedHTMLElement extends Ctor {
        attachShadow(options) {
            return shadow_root_1.attachShadow(this, options);
        }
        addEventListener(type, listener, options) {
            events_1.addCustomElementEventListener(this, type, listener, options);
        }
        removeEventListener(type, listener, options) {
            events_1.removeCustomElementEventListener(this, type, listener, options);
        }
        get shadowRoot() {
            const shadow = shadow_root_1.getShadowRoot(this);
            if (shadow.mode === shadow_root_1.ShadowRootMode.OPEN) {
                return shadow;
            }
            return null;
        }
        get tabIndex() {
            if (shadow_root_1.isDelegatingFocus(this) && language_1.isFalse(element_1.hasAttribute.call(this, 'tabindex'))) {
                // this cover the case where the default tabindex should be 0 because the
                // custom element is delegating its focus
                return 0;
            }
            // NOTE: Technically this should be `super.tabIndex` however Typescript
            // has a known bug while transpiling down to ES5
            // https://github.com/Microsoft/TypeScript/issues/338
            const descriptor = language_1.getPropertyDescriptor(Ctor.prototype, 'tabIndex');
            return descriptor.get.call(this);
        }
        set tabIndex(value) {
            // get the original value from the element before changing it, just in case
            // the custom element is doing something funky. we only really care about
            // the actual changes in the DOM.
            const hasAttr = element_1.hasAttribute.call(this, 'tabindex');
            const originalValue = element_1.tabIndexGetter.call(this);
            // run the super logic, which bridges the setter to the component
            // NOTE: Technically this should be `super.tabIndex` however Typescript
            // has a known bug while transpiling down to ES5
            // https://github.com/Microsoft/TypeScript/issues/338
            const descriptor = language_1.getPropertyDescriptor(Ctor.prototype, 'tabIndex');
            descriptor.set.call(this, value);
            // Check if the value from the dom has changed
            const newValue = element_1.tabIndexGetter.call(this);
            if ((!hasAttr || originalValue !== newValue)) {
                // Value has changed
                if (newValue === -1) {
                    // add the magic to skip this element
                    focus_1.handleFocusIn(this);
                }
                else if (newValue === 0 && shadow_root_1.isDelegatingFocus(this)) {
                    // Listen for focus if the new tabIndex is 0, and we are delegating focus
                    focus_1.handleFocus(this);
                }
                else {
                    // TabIndex is set to 0, but we aren't delegating focus, so we can ignore everything
                    focus_1.ignoreFocusIn(this);
                    focus_1.ignoreFocus(this);
                }
            }
            else if (originalValue === -1) {
                // remove the magic
                focus_1.ignoreFocusIn(this);
                focus_1.ignoreFocus(this);
            }
        }
        blur() {
            if (shadow_root_1.isDelegatingFocus(this)) {
                const currentActiveElement = focus_1.getActiveElement(this);
                if (!language_1.isNull(currentActiveElement)) {
                    // if there is an active element, blur it
                    currentActiveElement.blur();
                    return;
                }
            }
            super.blur();
        }
        get childNodes() {
            const owner = traverse_1.getNodeOwner(this);
            const childNodes = language_1.isNull(owner) ? [] : traverse_1.getAllMatches(owner, traverse_1.getFilteredChildNodes(this));
            return static_node_list_1.createStaticNodeList(childNodes);
        }
        get children() {
            // We cannot patch `children` in test mode
            // because JSDOM uses children for its "native"
            // querySelector implementation. If we patch this,
            // HTMLElement.prototype.querySelector.call(element) will not
            // return any elements from shadow, which is not what we want
            if (process.env.NODE_ENV === 'test') {
                return element_1.childrenGetter.call(this);
            }
            const owner = traverse_1.getNodeOwner(this);
            const childNodes = language_1.isNull(owner) ? [] : traverse_1.getAllMatches(owner, traverse_1.getFilteredChildNodes(this));
            return static_html_collection_1.createStaticHTMLCollection(language_1.ArrayFilter.call(childNodes, (node) => node instanceof Element));
        }
    };
}
exports.PatchedCustomElement = PatchedCustomElement;
//# sourceMappingURL=custom-element.js.map