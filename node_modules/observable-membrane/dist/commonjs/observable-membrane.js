/**
 * Copyright (C) 2017 salesforce.com, inc.
 */
'use strict';

const { isArray } = Array;
const { getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, } = Object;
const { push: ArrayPush, concat: ArrayConcat, map: ArrayMap, } = Array.prototype;
const ObjectDotPrototype = Object.prototype;
const OtS = {}.toString;
function toString(obj) {
    if (obj && obj.toString) {
        return obj.toString();
    }
    else if (typeof obj === 'object') {
        return OtS.call(obj);
    }
    else {
        return obj + '';
    }
}
function isUndefined(obj) {
    return obj === undefined;
}
const TargetSlot = Symbol();
// TODO: we are using a funky and leaky abstraction here to try to identify if
// the proxy is a compat proxy, and define the unwrap method accordingly.
// @ts-ignore
const { getKey } = Proxy;
const unwrap = getKey ?
    (replicaOrAny) => (replicaOrAny && getKey(replicaOrAny, TargetSlot)) || replicaOrAny
    : (replicaOrAny) => (replicaOrAny && replicaOrAny[TargetSlot]) || replicaOrAny;
function isObservable(value) {
    // intentionally checking for null and undefined
    if (value == null) {
        return false;
    }
    if (isArray(value)) {
        return true;
    }
    const proto = getPrototypeOf(value);
    return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);
}
function isObject(obj) {
    return typeof obj === 'object';
}

// Unwrap property descriptors
// We only need to unwrap if value is specified
function unwrapDescriptor(descriptor) {
    if ('value' in descriptor) {
        descriptor.value = unwrap(descriptor.value);
    }
    return descriptor;
}
function wrapDescriptor(membrane, descriptor) {
    if ('value' in descriptor) {
        descriptor.value = isObservable(descriptor.value) ? membrane.getProxy(descriptor.value) : descriptor.value;
    }
    return descriptor;
}
function lockShadowTarget(membrane, shadowTarget, originalTarget) {
    const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    targetKeys.forEach((key) => {
        let descriptor = getOwnPropertyDescriptor(originalTarget, key);
        // We do not need to wrap the descriptor if not configurable
        // Because we can deal with wrapping it when user goes through
        // Get own property descriptor. There is also a chance that this descriptor
        // could change sometime in the future, so we can defer wrapping
        // until we need to
        if (!descriptor.configurable) {
            descriptor = wrapDescriptor(membrane, descriptor);
        }
        ObjectDefineProperty(shadowTarget, key, descriptor);
    });
    preventExtensions(shadowTarget);
}
class ReactiveProxyHandler {
    constructor(membrane, value, options) {
        this.originalTarget = value;
        this.membrane = membrane;
        if (!isUndefined(options)) {
            this.valueMutated = options.valueMutated;
            this.valueObserved = options.valueObserved;
        }
    }
    get(shadowTarget, key) {
        const { originalTarget, membrane } = this;
        if (key === TargetSlot) {
            return originalTarget;
        }
        const value = originalTarget[key];
        const { valueObserved } = this;
        if (!isUndefined(valueObserved)) {
            valueObserved(originalTarget, key);
        }
        return membrane.getProxy(value);
    }
    set(shadowTarget, key, value) {
        const { originalTarget, valueMutated } = this;
        const oldValue = originalTarget[key];
        if (oldValue !== value) {
            originalTarget[key] = value;
            if (!isUndefined(valueMutated)) {
                valueMutated(originalTarget, key);
            }
        }
        else if (key === 'length' && isArray(originalTarget)) {
            // fix for issue #236: push will add the new index, and by the time length
            // is updated, the internal length is already equal to the new length value
            // therefore, the oldValue is equal to the value. This is the forking logic
            // to support this use case.
            if (!isUndefined(valueMutated)) {
                valueMutated(originalTarget, key);
            }
        }
        return true;
    }
    deleteProperty(shadowTarget, key) {
        const { originalTarget, valueMutated } = this;
        delete originalTarget[key];
        if (!isUndefined(valueMutated)) {
            valueMutated(originalTarget, key);
        }
        return true;
    }
    apply(shadowTarget, thisArg, argArray) {
        /* No op */
    }
    construct(target, argArray, newTarget) {
        /* No op */
    }
    has(shadowTarget, key) {
        const { originalTarget, valueObserved } = this;
        if (!isUndefined(valueObserved)) {
            valueObserved(originalTarget, key);
        }
        return key in originalTarget;
    }
    ownKeys(shadowTarget) {
        const { originalTarget } = this;
        return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    }
    isExtensible(shadowTarget) {
        const shadowIsExtensible = isExtensible(shadowTarget);
        if (!shadowIsExtensible) {
            return shadowIsExtensible;
        }
        const { originalTarget, membrane } = this;
        const targetIsExtensible = isExtensible(originalTarget);
        if (!targetIsExtensible) {
            lockShadowTarget(membrane, shadowTarget, originalTarget);
        }
        return targetIsExtensible;
    }
    setPrototypeOf(shadowTarget, prototype) {
        if (process.env.NODE_ENV !== 'production') {
            throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);
        }
    }
    getPrototypeOf(shadowTarget) {
        const { originalTarget } = this;
        return getPrototypeOf(originalTarget);
    }
    getOwnPropertyDescriptor(shadowTarget, key) {
        const { originalTarget, membrane, valueObserved } = this;
        // keys looked up via hasOwnProperty need to be reactive
        if (!isUndefined(valueObserved)) {
            valueObserved(originalTarget, key);
        }
        let desc = getOwnPropertyDescriptor(originalTarget, key);
        if (isUndefined(desc)) {
            return desc;
        }
        const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);
        if (!desc.configurable && !shadowDescriptor) {
            // If descriptor from original target is not configurable,
            // We must copy the wrapped descriptor over to the shadow target.
            // Otherwise, proxy will throw an invariant error.
            // This is our last chance to lock the value.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
            desc = wrapDescriptor(membrane, desc);
            ObjectDefineProperty(shadowTarget, key, desc);
        }
        return shadowDescriptor || desc;
    }
    preventExtensions(shadowTarget) {
        const { originalTarget, membrane } = this;
        lockShadowTarget(membrane, shadowTarget, originalTarget);
        preventExtensions(originalTarget);
        return true;
    }
    defineProperty(shadowTarget, key, descriptor) {
        const { originalTarget, membrane, valueMutated } = this;
        const { configurable } = descriptor;
        // We have to check for value in descriptor
        // because Object.freeze(proxy) calls this method
        // with only { configurable: false, writeable: false }
        // Additionally, method will only be called with writeable:false
        // if the descriptor has a value, as opposed to getter/setter
        // So we can just check if writable is present and then see if
        // value is present. This eliminates getter and setter descriptors
        if ('writable' in descriptor && !('value' in descriptor)) {
            const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);
            descriptor.value = originalDescriptor.value;
        }
        ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));
        if (configurable === false) {
            ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor));
        }
        if (!isUndefined(valueMutated)) {
            valueMutated(originalTarget, key);
        }
        return true;
    }
}

function wrapDescriptor$1(membrane, descriptor) {
    if ('value' in descriptor) {
        descriptor.value = isObservable(descriptor.value) ? membrane.getReadOnlyProxy(descriptor.value) : descriptor.value;
    }
    return descriptor;
}
class ReadOnlyHandler {
    constructor(membrane, value, options) {
        this.originalTarget = value;
        this.membrane = membrane;
        if (!isUndefined(options)) {
            this.valueObserved = options.valueObserved;
        }
    }
    get(shadowTarget, key) {
        const { membrane, originalTarget } = this;
        if (key === TargetSlot) {
            return originalTarget;
        }
        const value = originalTarget[key];
        const { valueObserved } = this;
        if (!isUndefined(valueObserved)) {
            valueObserved(originalTarget, key);
        }
        return membrane.getReadOnlyProxy(value);
    }
    set(shadowTarget, key, value) {
        if (process.env.NODE_ENV !== 'production') {
            const { originalTarget } = this;
            throw new Error(`Invalid mutation: Cannot set "${key.toString()}" on "${originalTarget}". "${originalTarget}" is read-only.`);
        }
        return false;
    }
    deleteProperty(shadowTarget, key) {
        if (process.env.NODE_ENV !== 'production') {
            const { originalTarget } = this;
            throw new Error(`Invalid mutation: Cannot delete "${key.toString()}" on "${originalTarget}". "${originalTarget}" is read-only.`);
        }
        return false;
    }
    apply(shadowTarget, thisArg, argArray) {
        /* No op */
    }
    construct(target, argArray, newTarget) {
        /* No op */
    }
    has(shadowTarget, key) {
        const { originalTarget } = this;
        const { valueObserved } = this;
        if (!isUndefined(valueObserved)) {
            valueObserved(originalTarget, key);
        }
        return key in originalTarget;
    }
    ownKeys(shadowTarget) {
        const { originalTarget } = this;
        return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    }
    setPrototypeOf(shadowTarget, prototype) {
        if (process.env.NODE_ENV !== 'production') {
            const { originalTarget } = this;
            throw new Error(`Invalid prototype mutation: Cannot set prototype on "${originalTarget}". "${originalTarget}" prototype is read-only.`);
        }
    }
    getOwnPropertyDescriptor(shadowTarget, key) {
        const { originalTarget, membrane, valueObserved } = this;
        // keys looked up via hasOwnProperty need to be reactive
        if (!isUndefined(valueObserved)) {
            valueObserved(originalTarget, key);
        }
        let desc = getOwnPropertyDescriptor(originalTarget, key);
        if (isUndefined(desc)) {
            return desc;
        }
        const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);
        if (!desc.configurable && !shadowDescriptor) {
            // If descriptor from original target is not configurable,
            // We must copy the wrapped descriptor over to the shadow target.
            // Otherwise, proxy will throw an invariant error.
            // This is our last chance to lock the value.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
            desc = wrapDescriptor$1(membrane, desc);
            ObjectDefineProperty(shadowTarget, key, desc);
        }
        return shadowDescriptor || desc;
    }
    preventExtensions(shadowTarget) {
        if (process.env.NODE_ENV !== 'production') {
            const { originalTarget } = this;
            throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}". "${originalTarget} is read-only.`);
        }
        return false;
    }
    defineProperty(shadowTarget, key, descriptor) {
        if (process.env.NODE_ENV !== 'production') {
            const { originalTarget } = this;
            throw new Error(`Invalid mutation: Cannot defineProperty "${key.toString()}" on "${originalTarget}". "${originalTarget}" is read-only.`);
        }
        return false;
    }
}

function getTarget(item) {
    return item && item[TargetSlot];
}
function extract(objectOrArray) {
    if (isArray(objectOrArray)) {
        return objectOrArray.map((item) => {
            const original = getTarget(item);
            if (original) {
                return extract(original);
            }
            return item;
        });
    }
    const obj = ObjectCreate(getPrototypeOf(objectOrArray));
    const names = getOwnPropertyNames(objectOrArray);
    return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray))
        .reduce((seed, key) => {
        const item = objectOrArray[key];
        const original = getTarget(item);
        if (original) {
            seed[key] = extract(original);
        }
        else {
            seed[key] = item;
        }
        return seed;
    }, obj);
}
const formatter = {
    header: (plainOrProxy) => {
        const originalTarget = plainOrProxy[TargetSlot];
        if (!originalTarget) {
            return null;
        }
        const obj = extract(plainOrProxy);
        return ['object', { object: obj }];
    },
    hasBody: () => {
        return false;
    },
    body: () => {
        return null;
    }
};
function init() {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    // Custom Formatter for Dev Tools
    // To enable this, open Chrome Dev Tools
    // Go to Settings,
    // Under console, select "Enable custom formatters"
    // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview
    const devWindow = window;
    const devtoolsFormatters = devWindow.devtoolsFormatters || [];
    ArrayPush.call(devtoolsFormatters, formatter);
    devWindow.devtoolsFormatters = devtoolsFormatters;
}

if (process.env.NODE_ENV !== 'production') {
    init();
}
function createShadowTarget(value) {
    let shadowTarget = undefined;
    if (isArray(value)) {
        shadowTarget = [];
    }
    else if (isObject(value)) {
        shadowTarget = {};
    }
    return shadowTarget;
}
class ReactiveMembrane {
    constructor(options) {
        this.objectGraph = new WeakMap();
        if (!isUndefined(options)) {
            this.valueDistortion = options.valueDistortion;
            this.valueMutated = options.valueMutated;
            this.valueObserved = options.valueObserved;
        }
    }
    getProxy(value) {
        const { valueDistortion } = this;
        const distorted = isUndefined(valueDistortion) ? value : valueDistortion(value);
        if (isObservable(distorted)) {
            const o = this.getReactiveState(distorted);
            // when trying to extract the writable version of a readonly
            // we return the readonly.
            return o.readOnly === value ? value : o.reactive;
        }
        return distorted;
    }
    getReadOnlyProxy(value) {
        const { valueDistortion } = this;
        const distorted = isUndefined(valueDistortion) ? value : valueDistortion(value);
        if (isObservable(distorted)) {
            return this.getReactiveState(distorted).readOnly;
        }
        return distorted;
    }
    unwrapProxy(p) {
        return unwrap(p);
    }
    getReactiveState(value) {
        const membrane = this;
        const { objectGraph, valueMutated, valueObserved, } = membrane;
        value = unwrap(value);
        let reactiveState = objectGraph.get(value);
        if (reactiveState) {
            return reactiveState;
        }
        reactiveState = ObjectDefineProperties(ObjectCreate(null), {
            reactive: {
                get() {
                    const reactiveHandler = new ReactiveProxyHandler(membrane, value, {
                        valueMutated,
                        valueObserved,
                    });
                    // caching the reactive proxy after the first time it is accessed
                    const proxy = new Proxy(createShadowTarget(value), reactiveHandler);
                    ObjectDefineProperty(this, 'reactive', { value: proxy });
                    return proxy;
                },
                configurable: true,
            },
            readOnly: {
                get() {
                    const readOnlyHandler = new ReadOnlyHandler(membrane, value, {
                        valueObserved,
                    });
                    // caching the readOnly proxy after the first time it is accessed
                    const proxy = new Proxy(createShadowTarget(value), readOnlyHandler);
                    ObjectDefineProperty(this, 'readOnly', { value: proxy });
                    return proxy;
                },
                configurable: true,
            }
        });
        objectGraph.set(value, reactiveState);
        return reactiveState;
    }
}

module.exports = ReactiveMembrane;
/** version: 0.25.0 */
